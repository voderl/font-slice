const fs = require('fs');
const path = require('path');
const { Font } = require('fonteditor-core');
const Fontmin = require('fontmin');
const bufferToVinyl = require('buffer-to-vinyl');
const unicodeRanges = require('./google-font-unicode-range.json');
const utils = require('./utils');
const { generateCss, generateHtml } = require('./template');
const createFolderServer = require('./server');

async function createFontSlice({
  fontPath,
  outputDir,
  fontFamily,
  formats = ['woff2'],
  // normal
  fontWeight = 'normal',
  // normal
  fontStyle = 'normal',
  // swap
  fontDisplay = 'swap',
  customUnicodeRange = unicodeRanges,
  hinting = false,
}) {
  const fontBuffer = fs.readFileSync(fontPath);

  const isOtf = path.extname(fontPath) === '.otf';

  if (!['.otf', '.ttf'].includes(path.extname(fontPath)))
    throw new Error(`暂时只支持 ttf、otf 格式`);

  const font = Font.create(fontBuffer, {
    type: isOtf ? 'otf' : 'ttf',
  });

  // 获取输入字体包含的所有 unicode
  const charMap = font.data.cmap;

  // 和 unicodeRange 做 filter，只保留输入字体中包含的 unicode
  const filteredRanges = customUnicodeRange
    .map(({ unicodes }) => {
      return unicodes.filter((unicode) => unicode in charMap);
    })
    .filter((item) => item.length > 0);

  const { name } = path.parse(fontPath);

  const outputFontFamily = utils.formatFontFamily(fontFamily || name);

  const cssList = await Promise.all(
    filteredRanges.map(async (range, index) => {
      const fileName = `${name}.${index + 1}`;

      const fontmin = new Fontmin();
      fontmin.getFiles = () => {
        return bufferToVinyl.stream(fontBuffer, fileName);
      };

      if (isOtf) {
        fontmin.use(Fontmin.otf2ttf());
      }

      fontmin.use(
        Fontmin.glyph({
          text: utils.unicodeToSubset(range),
          hinting,
        }),
      );

      formats.map((format) => {
        // 'woff' | 'woff2' | 'ttf' | 'eot' | 'svg'
        if (format === 'woff') {
          fontmin.use(Fontmin.ttf2woff());
          return;
        }
        if (format === 'woff2') {
          fontmin.use(Fontmin.ttf2woff2());
          return;
        }
        if (format === 'eot') {
          fontmin.use(Fontmin.ttf2eot());
          return;
        }
        if (format === 'svg') {
          fontmin.use(Fontmin.ttf2svg());
          return;
        }
      });

      fontmin.dest(outputDir);

      console.log(`正在生成字体文件 ${fileName}`);

      await new Promise((resolve, reject) => {
        fontmin.run(function (err, files) {
          if (err) {
            reject(err);
          }
          console.log(`写入字体 ${fileName} 成功`);
          resolve();
        });
      });

      // 如果不包含 ttf 把生成的 ttf 删除
      if (!formats.includes('ttf')) {
        const ttfPath = path.resolve(outputDir, `${fileName}.ttf`);
        if (fs.existsSync(ttfPath)) {
          fs.rmSync(ttfPath);
        }
      }

      return generateCss({
        name: fileName,
        fontFamily: outputFontFamily,
        fontWeight,
        fontStyle,
        fontDisplay,
        formats,
        unicodeRange: utils.createUnicodeRange(range),
      });
    }),
  );
  fs.writeFileSync(
    path.resolve(outputDir, 'font.css'),
    `/** generated by https://github.com/voderl/font-slice */
${cssList.join('\n')}
`,
  );
  fs.writeFileSync(
    path.resolve(outputDir, 'index.html'),
    generateHtml(outputFontFamily),
  );

  createFolderServer(outputDir);
}

module.exports = createFontSlice;
